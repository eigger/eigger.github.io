<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Gicisky Image Uploader (Ïä¨ÎùºÏù¥Îçî & ÎùºÎ≤® ÏÑ†ÌÉù, Ï†ÑÏ≤¥ ÏΩîÎìú)</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Nanum+Gothic:wght@400;700&display=swap');
    :root {
      --bg-color: #f8f9fa;
      --text-color: #333;
      --primary-color: #007bff;
      --secondary-color: #555;
      --button-bg: #007bff;
      --button-hover: #0056b3;
      --container-bg: white;
      --shadow-color: rgba(0, 0, 0, 0.1);
      --status-bg: #f3f3f3;
    }
    [data-theme="dark"] {
      --bg-color: #121212;
      --text-color: #f8f9fa;
      --primary-color: #90caf9;
      --secondary-color: #ccc;
      --container-bg: #1e1e1e;
      --shadow-color: rgba(255, 255, 255, 0.1);
      --status-bg: #333;
    }
    body {
      font-family: 'Nanum Gothic', sans-serif;
      text-align: center;
      margin: 20px;
      background-color: var(--bg-color);
      color: var(--text-color);
      transition: background-color 0.3s, color 0.3s;
    }
    h1, h2 {
      color: var(--primary-color);
      margin-bottom: 10px;
      font-size: 20px;
    }
    label {
      font-weight: bold;
      margin-right: 5px;
      color: var(--secondary-color);
      font-size: 14px;
    }
    input,
    select,
    button {
      padding: 8px;
      margin: 5px;
      border-radius: 5px;
      border: 1px solid #ccc;
      font-size: 14px;
    }
    button {
      background-color: var(--button-bg);
      color: #fff;
      cursor: pointer;
      transition: background-color 0.3s;
      border: none;
    }
    button:hover {
      background-color: var(--button-hover);
    }
    .container {
      max-width: 450px;
      margin: 0 auto;
      background: var(--container-bg);
      padding: 15px;
      border-radius: 10px;
      box-shadow: 0px 0px 10px var(--shadow-color);
    }
    .select-label {
      margin: 10px 0;
    }
    canvas {
      border: 1px solid black;
      display: block;
      margin: 10px auto;
    }
    #pixelData {
      /* display: none; */
    }
    #status, #log {
      text-align: left;
      padding: 10px;
      border-radius: 5px;
      background-color: var(--status-bg);
      color: var(--text-color);
      font-size: 12px;
      margin-top: 10px;
    }
    .pixlr-button {
      display: inline-block;
      margin-top: 10px;
      padding: 10px 15px;
      background-color: var(--button-bg);
      color: white;
      text-decoration: none;
      border-radius: 5px;
      transition: background-color 0.3s;
      border: none;
      font-size: 14px;
      cursor: pointer;
    }
    .theme-container {
      display: flex;
      justify-content: space-evenly;
      align-items: center;
    }
    .theme-toggle {
      font-size: 24px;
      cursor: pointer;
      border: none;
      background: none;
    }
    .slider-container {
      margin: 10px 0;
      display: flex;
      justify-content: space-around;
      align-items: center;
    }
    .slider-container label {
      font-size: 14px;
    }
  </style>
</head>
<body data-theme="light">
  <div class="container">
    <!-- ÌÖåÎßà Î∞è Ï†úÎ™© ÏòÅÏó≠ -->
    <div class="theme-container">
      <h1>Gicisky Image Uploader</h1>
      <button class="theme-toggle" id="themeToggle">‚òÄÔ∏è</button>
    </div>

    <!-- ÎùºÎ≤® ÌÉÄÏûÖ ÏÑ†ÌÉù (Ìï≠ÏÉÅ Î≥¥ÏûÑ) -->
    <div class="select-label">
      <label for="optionsSelect">ÎùºÎ≤® ÌÉÄÏûÖ ÏÑ†ÌÉù</label>
      <select id="optionsSelect">
        <option value="410B">250x122 BWR</option>
        <option value="40A0">250x132 TFT</option>
      </select>
    </div>

    <!-- Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú -->
    <div class="file-upload">
      <label for="imageUpload">Ïù¥ÎØ∏ÏßÄ ÏÑ†ÌÉù</label>
      <input type="file" id="imageUpload" accept="image/*">
    </div>
    <!-- Ï≤¥ÌÅ¨Î∞ïÏä§ ÏòµÏÖò -->
    <div class="options" style="display: none;">
        <label><input type="checkbox" id="ditherrin"> Dithering</label>
        <label><input type="checkbox" id="compressionCheckbox"> Compression</label>
        <label><input type="checkbox" id="secondColorCheckbox"> Second Color</label>
        <label><input type="checkbox" id="mirrorCheckbox"> Mirror</label>
        <label><input type="checkbox" id="tftCheckbox"> TFT</label>
    </div>
    <!-- Ïä¨ÎùºÏù¥Îçî Ïª®Ìä∏Î°§ -->
    <div class="slider-container">
      <label for="luminanceSlider">Luminance ÏûÑÍ≥ÑÍ∞í: <span id="lumVal">128</span></label>
      <input type="range" id="luminanceSlider" min="0" max="255" value="128">
    </div>
    <div class="slider-container">
      <label for="redSlider">Red ÏûÑÍ≥ÑÍ∞í: <span id="redVal">170</span></label>
      <input type="range" id="redSlider" min="0" max="255" value="170">
    </div>

    <!-- Ï∫îÎ≤ÑÏä§ Î∞è Ìé∏Ïßë Î≤ÑÌäº -->
    <canvas id="myCanvas" width="250" height="128"></canvas>
    <button class="pixlr-button" id="pixlrButton">üì∑ PixlrÏóêÏÑú Ïù¥ÎØ∏ÏßÄ Ìé∏Ïßë</button>

    <!-- Ïà®ÍπÄ ÌÖçÏä§Ìä∏ÏòÅÏó≠ (ÌîΩÏÖÄ Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•) -->
    <textarea id="pixelData"></textarea>

    <!-- BLE ÏóÖÎ°úÎìú ÏÑπÏÖò (ÌïÑÏöî Ïãú) -->
    <div id="ble-upload">
      <button id="connectButton">3. Ïó∞Í≤∞</button>
      <button id="sendImageButton" disabled>4. Ïù¥ÎØ∏ÏßÄ Ï†ÑÏÜ°</button>
      <button id="clearLogButton">Î°úÍ∑∏ Ï†ïÎ¶¨</button>
      <div id="status">Upload status</div>
      <div id="log">Logs:</div>
    </div>
  </div>

  <!-- JavaScript: Í∏∞Îä•Î≥Ñ Î™®ÎìàÌôî (Ïä¨ÎùºÏù¥Îçî Ïò§Î≤ÑÎ†àÏù¥ Ï†ÅÏö© Î∞è pixelData Í∞±Ïã†) -->
  <script>
    (function() {
      /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Ïú†Ìã∏Î¶¨Ìã∞ Ìï®Ïàò ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
      const Utils = {
        bufferToHex(buffer) {
          return [...new Uint8Array(buffer)]
            .map(x => x.toString(16).padStart(2, '0'))
            .join('');
        },
        hexToBytes(hex) {
          let bytes = [];
          for (let c = 0; c < hex.length; c += 2) {
            bytes.push(parseInt(hex.substr(c, 2), 16));
          }
          return new Uint8Array(bytes);
        },
        bytesToHex(data) {
          return Array.from(new Uint8Array(data))
            .map(i => ("0" + i.toString(16)).slice(-2))
            .join('');
        },
        intToHex(num) {
          const hexStr = ("00000000" + num.toString(16)).slice(-8);
          return hexStr.substring(6, 8) + hexStr.substring(4, 6) + hexStr.substring(2, 4) + hexStr.substring(0, 2);
        },
        clamp(value) {
          return Math.max(0, Math.min(255, value));
        }
      };

      /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ÌÖåÎßà Í¥ÄÎ¶¨ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
      const ThemeManager = {
        toggleTheme() {
          const body = document.body;
          const toggleBtn = document.getElementById('themeToggle');
          const currentTheme = body.getAttribute("data-theme");
          const newTheme = currentTheme === "light" ? "dark" : "light";
          body.setAttribute("data-theme", newTheme);
          toggleBtn.textContent = newTheme === "light" ? "‚òÄÔ∏è" : "üåô";
        }
      };

      /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Ï∫îÎ≤ÑÏä§ Í¥ÄÎ¶¨ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
      const CanvasManager = {
        canvas: document.getElementById('myCanvas'),
        ctx: document.getElementById('myCanvas').getContext('2d'),
        originalImageData: null, // ÏóÖÎ°úÎìúÎêú ÏõêÎ≥∏ Ïù¥ÎØ∏ÏßÄ Îç∞Ïù¥ÌÑ∞Î•º Ï†ÄÏû•
        initCanvas() {
          const width = parseInt(document.getElementById('widthInput')?.value || 250);
          const height = parseInt(document.getElementById('heightInput')?.value || 128);
          this.canvas.width = width;
          this.canvas.height = height;
          this.ctx.fillStyle = 'white';
          this.ctx.fillRect(0, 0, width, height);
        },
        
        decodeTypes() {
            var select = document.getElementById("optionsSelect");
            var selectedValue = select.options[select.selectedIndex].value;
            var rawType = Number("0x" + selectedValue);
            var screenResolution = (rawType >> 5) & 63;
            var dispPtype = (rawType >> 3) & 3;
            var availColors = ((rawType >> 1) & 3) + ((rawType >> 10) & 12);
            var singleDoubleMirror = rawType & 1;
            var canDoCompression = (rawType & 0x4000) ? 0 : 1;

            console.log("Display Resolution: " + screenResolution);
            console.log("Display Type: " + dispPtype);
            console.log("Display Colors: " + availColors);
            console.log("Display Mirror: " + singleDoubleMirror);
            console.log("Display Compression: " + canDoCompression);

            document.getElementById('ditherrin').checked = false;
            if (canDoCompression)
                document.getElementById('compressionCheckbox').checked = true;
            else
                document.getElementById('compressionCheckbox').checked = false;


            switch (screenResolution) {
                case 0:
                widthInput
                    document.getElementById('heightInput').value = "104";
                    document.getElementById('widthInput').value = "212";
                    break;
                case 1:
                    document.getElementById('heightInput').value = "128";
                    document.getElementById('widthInput').value = "296";
                    break;
                case 2:
                    document.getElementById('heightInput').value = "400";
                    document.getElementById('widthInput').value = "300";
                    break;
                case 3:
                    document.getElementById('heightInput').value = "384";
                    document.getElementById('widthInput').value = "640";
                    break;
                case 4:
                    document.getElementById('heightInput').value = "640";
                    document.getElementById('widthInput').value = "960";
                    break;
                case 5:
                    document.getElementById('heightInput').value = "132";
                    document.getElementById('widthInput').value = "250";
                    break;
                case 6:
                    document.getElementById('heightInput').value = "96";
                    document.getElementById('widthInput').value = "196";
                    break;
                case 7:
                    document.getElementById('heightInput').value = "480";
                    document.getElementById('widthInput').value = "640";
                    break;
                case 8:
                    document.getElementById('heightInput').value = "128";
                    document.getElementById('widthInput').value = "250";
                    break;
                case 9:
                    document.getElementById('heightInput').value = "800";
                    document.getElementById('widthInput').value = "480";
                    break;
                case 10:
                    document.getElementById('heightInput').value = "480";
                    document.getElementById('widthInput').value = "280";
                    break;
            }

            switch (dispPtype) {
                case 0:// TFT
                    document.getElementById('mirrorCheckbox').checked = false;
                    document.getElementById('tftCheckbox').checked = true;
                    break;
                case 1:// EPA
                    document.getElementById('mirrorCheckbox').checked = false;
                    document.getElementById('tftCheckbox').checked = false;
                    break;
                case 2:// EPA1
                    document.getElementById('mirrorCheckbox').checked = false;
                    document.getElementById('tftCheckbox').checked = false;
                    break;
                case 3:// EPA2
                    document.getElementById('mirrorCheckbox').checked = false;
                    document.getElementById('tftCheckbox').checked = false;
                    break;
            }
            switch (availColors) {
                case 0:// BW
                    document.getElementById('secondColorCheckbox').checked = false;
                    break;
                case 1:// BWR
                    document.getElementById('secondColorCheckbox').checked = true;
                    break;
                case 2:// BWY
                    document.getElementById('secondColorCheckbox').checked = true;
                    break;
                case 3:// BWRY
                    document.getElementById('secondColorCheckbox').checked = true;
                    break;
                case 4:// BWRGBYO
                    document.getElementById('secondColorCheckbox').checked = true;
                    break;
            }
            switch (singleDoubleMirror) {
                case 0:// Single image
                    break;
                case 1:// 2 Images
                    break;
            }
        },
        /* displayOverlay() : ÏõêÎ≥∏ Ïù¥ÎØ∏ÏßÄ Îç∞Ïù¥ÌÑ∞Î•º Ïù¥Ïö©Ìï¥
           - bwData: luminance Í∏∞Ï§Ä (luminance > lumThreshold ‚Üí Ìù∞ÏÉâ, ÏïÑÎãàÎ©¥ Í≤ÄÏ†ï)
           - redOverlayData: (r > redThreshold && g < redThreshold)Ïù¥Î©¥ Îπ®Í∞ï, ÏïÑÎãàÎ©¥ Ìà¨Î™Ö
           ÏµúÏ¢Ö Ìï©ÏÑ±ÌïòÏó¨ Ï∫îÎ≤ÑÏä§Ïóê Ï∂úÎ†•ÌïòÍ≥†, Í∑∏ Í≤∞Í≥ºÎ•º pixelDataÏóê Ìó•Ïä§ Î¨∏ÏûêÏó¥Î°ú Ï†ÄÏû•
        */
        displayOverlay() {
          if (!this.originalImageData) return;
          const width = this.canvas.width;
          const height = this.canvas.height;
          const origData = this.originalImageData;
          const bwData = this.ctx.createImageData(width, height);
          const redOverlayData = this.ctx.createImageData(width, height);
          const finalData = this.ctx.createImageData(width, height);

          // Ïä¨ÎùºÏù¥Îçî Í∞í ÏùΩÍ∏∞
          const lumThreshold = parseInt(document.getElementById('luminanceSlider').value);
          const redThreshold = parseInt(document.getElementById('redSlider').value);

          for (let i = 0; i < origData.data.length; i += 4) {
            const r = origData.data[i];
            const g = origData.data[i + 1];
            const b = origData.data[i + 2];

            // ÌùëÎ∞± Ïù¥ÏßÑÌôî (luminance Í∏∞Ï§Ä)
            const luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b;
            if (luminance > lumThreshold) {
              bwData.data[i]     = 255;
              bwData.data[i + 1] = 255;
              bwData.data[i + 2] = 255;
              bwData.data[i + 3] = 255;
            } else {
              bwData.data[i]     = 0;
              bwData.data[i + 1] = 0;
              bwData.data[i + 2] = 0;
              bwData.data[i + 3] = 255;
            }

            // Îπ®Í∞ï Ïò§Î≤ÑÎ†àÏù¥: r > redThreshold && g < redThresholdÏù¥Î©¥ Îπ®Í∞ï, ÏïÑÎãàÎ©¥ Ìà¨Î™Ö
            if (r > redThreshold && g < redThreshold) {
              redOverlayData.data[i]     = 255;
              redOverlayData.data[i + 1] = 0;
              redOverlayData.data[i + 2] = 0;
              redOverlayData.data[i + 3] = 255;
            } else {
              redOverlayData.data[i]     = 0;
              redOverlayData.data[i + 1] = 0;
              redOverlayData.data[i + 2] = 0;
              redOverlayData.data[i + 3] = 0;
            }

            // ÏµúÏ¢Ö Ìï©ÏÑ±: Îπ®Í∞ï Ïò§Î≤ÑÎ†àÏù¥Í∞Ä Ï†ÅÏö©Îêú ÌîΩÏÖÄÏùÄ Îπ®Í∞ï, Í∑∏Î†áÏßÄ ÏïäÏúºÎ©¥ bwData
            if (redOverlayData.data[i + 3] > 0) {
              finalData.data[i]     = redOverlayData.data[i];
              finalData.data[i + 1] = redOverlayData.data[i + 1];
              finalData.data[i + 2] = redOverlayData.data[i + 2];
              finalData.data[i + 3] = 255;
            } else {
              finalData.data[i]     = bwData.data[i];
              finalData.data[i + 1] = bwData.data[i + 1];
              finalData.data[i + 2] = bwData.data[i + 2];
              finalData.data[i + 3] = 255;
            }
          }

          this.ctx.clearRect(0, 0, width, height);
          this.ctx.putImageData(finalData, 0, 0);
          this.getPixelData();
        },
        
        getPixelData() {
            if (document.getElementById('ditherrin').checked)
                applyDithering();
            var compressionEnabled = document.getElementById('compressionCheckbox').checked;
            var secondColorEnabled = document.getElementById('secondColorCheckbox').checked;
            var mirrorEnabled = document.getElementById('mirrorCheckbox').checked;
            var tftEnabled = document.getElementById('tftCheckbox').checked;
            var canvas = document.getElementById('myCanvas');
            var ctx = canvas.getContext('2d');
            var width = canvas.width;
            var height = canvas.height;
            var imageData = ctx.getImageData(0, 0, width, height);
            // Ïä¨ÎùºÏù¥Îçî Í∞í ÏùΩÍ∏∞
            const lumThreshold = parseInt(document.getElementById('luminanceSlider').value);
            const redThreshold = parseInt(document.getElementById('redSlider').value);
            let originalCanvas = document.createElement("canvas");
            let originalCtx = originalCanvas.getContext("2d");
            originalCanvas.width = canvas.width;
            originalCanvas.height = canvas.height;
            originalCtx.putImageData(imageData, 0, 0);

            if (tftEnabled) {
                var tempCanvas = document.createElement('canvas');
                var tempCtx = tempCanvas.getContext('2d');
                width = canvas.width / 2;
                height = canvas.height * 2;
                tempCanvas.width = width;
                tempCanvas.height = height;

                // 4. ÏõêÎ≥∏ Ï∫îÎ≤ÑÏä§Î•º ÏÉàÎ°úÏö¥ ÌÅ¨Í∏∞Î°ú Í∑∏Î¶¨Í∏∞ (Î¶¨ÏÇ¨Ïù¥Ïßï)
                tempCtx.drawImage(originalCanvas, 0, 0, imageData.width, imageData.height, 0, 0, width, height);

                // 5. Î¶¨ÏÇ¨Ïù¥Ï¶àÎêú Ïù¥ÎØ∏ÏßÄ Îç∞Ïù¥ÌÑ∞Î•º Î∞òÌôò
                imageData = tempCtx.getImageData(0, 0, width, height);
            }

            if (mirrorEnabled) {
                var tempCanvas = document.createElement('canvas');
                var tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = width;
                tempCanvas.height = height;

                tempCtx.translate(width, 0);
                tempCtx.scale(-1, 1);
                tempCtx.drawImage(originalCanvas, 0, 0, width, height);
                imageData = tempCtx.getImageData(0, 0, width, height);
            }

            var pixels = imageData.data;
            var byteData = [];
            var byteDataRed = [];
            var currentByte = 0;
            var currentByteRed = 0;
            var bitPosition = 7;
            for (var x = 0; x < width; x++) {
                for (var y = 0; y < height; y++) {
                    var curr = (Math.round(y * width) + x) * 4;
                    var r = pixels[curr];
                    var g = pixels[curr + 1];
                    var b = pixels[curr + 2];
                    var luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b;
                    if (luminance > lumThreshold) {
                        currentByte |= (1 << bitPosition);
                    }
                    if (r > redThreshold && g < redThreshold) {
                        currentByteRed |= (1 << bitPosition);
                    }
                    bitPosition--;
                    if (bitPosition < 0) {
                        byteData.push(currentByte);
                        byteDataRed.push(currentByteRed);
                        currentByte = 0;
                        currentByteRed = 0;
                        bitPosition = 7;
                    }
                }
            }

            if (bitPosition !== 7) {
                byteData.push(currentByte);
                byteDataRed.push(currentByteRed);
            }

            var byteDataCompressed = [];
            var pixelDataTextarea = document.getElementById('pixelData');

            if (compressionEnabled) {
                var currentPosi = 0;
                var byte_per_line = height / 8;
                byteDataCompressed.push(0x00);
                byteDataCompressed.push(0x00);
                byteDataCompressed.push(0x00);
                byteDataCompressed.push(0x00);
                for (var i = 0; i < width; i += 1) {
                    byteDataCompressed.push(0x75);
                    byteDataCompressed.push(byte_per_line + 7);
                    byteDataCompressed.push(byte_per_line);
                    byteDataCompressed.push(0x00);
                    byteDataCompressed.push(0x00);
                    byteDataCompressed.push(0x00);
                    byteDataCompressed.push(0x00);
                    for (var b = 0; b < byte_per_line; b++) {
                        byteDataCompressed.push(byteData[currentPosi++]);
                    }
                }
                if (secondColorEnabled) {
                    for (var i = 0; i < width; i += 1) {
                        byteDataCompressed.push(0x75);
                        byteDataCompressed.push(byte_per_line + 7);
                        byteDataCompressed.push(byte_per_line);
                        byteDataCompressed.push(0x00);
                        byteDataCompressed.push(0x00);
                        byteDataCompressed.push(0x00);
                        byteDataCompressed.push(0x00);
                        for (var b = 0; b < byte_per_line; b++) {
                            byteDataCompressed.push(byteData[currentPosi++]);
                        }
                    }
                }
                byteDataCompressed[0] = byteDataCompressed.length & 0xff;
                byteDataCompressed[1] = (byteDataCompressed.length >> 8) & 0xff;
                byteDataCompressed[2] = (byteDataCompressed.length >> 16) & 0xff;
                byteDataCompressed[3] = (byteDataCompressed.length >> 24) & 0xff;
            } else {
                for (var b = 0; b < byteData.length; b++) {
                    byteDataCompressed.push(byteData[b]);
                }
                if (secondColorEnabled) {
                    byteDataCompressed = [...byteDataCompressed, ...byteDataRed];
                }
            }
            pixelDataTextarea.value = Utils.bufferToHex(byteDataCompressed);

        },
        /* Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú Ïãú ÏõêÎ≥∏ Ïù¥ÎØ∏ÏßÄÎ•º Ï∫îÎ≤ÑÏä§Ïóê Í∑∏Î¶¨Í≥† Ï†ÄÏû• */
        drawImage(img) {
          const canvasW = this.canvas.width;
          const canvasH = this.canvas.height;
          const ctx = this.ctx;
          const scale = Math.max(canvasW / img.width, canvasH / img.height);
          const newW = img.width * scale;
          const newH = img.height * scale;
          const offsetX = (canvasW - newW) / 2;
          const offsetY = (canvasH - newH) / 2;
          ctx.clearRect(0, 0, canvasW, canvasH);
          ctx.fillStyle = 'white';
          ctx.fillRect(0, 0, canvasW, canvasH);
          ctx.drawImage(img, offsetX, offsetY, newW, newH);
          // ÏõêÎ≥∏ Ïù¥ÎØ∏ÏßÄÎ•º Ï†ÄÏû•
          this.originalImageData = ctx.getImageData(0, 0, canvasW, canvasH);
          this.displayOverlay();
        },
        applyDithering() {
          const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
          const data = imageData.data;
          for (let i = 0; i < data.length; i += 4) {
            const oldR = data[i], oldG = data[i + 1], oldB = data[i + 2];
            const [newR, newG, newB] = this.findNearestColor(oldR, oldG, oldB);
            data[i] = newR; 
            data[i + 1] = newG; 
            data[i + 2] = newB;
            const errR = oldR - newR, errG = oldG - newG, errB = oldB - newB;
            const distributeError = (index, factor) => {
              if (index < 0 || index >= data.length) return;
              data[index] = Utils.clamp(data[index] + errR * factor);
              data[index + 1] = Utils.clamp(data[index + 1] + errG * factor);
              data[index + 2] = Utils.clamp(data[index + 2] + errB * factor);
            };
            if (i + 4 < data.length) distributeError(i + 4, 7 / 16);
            const nextLine = i + 4 * this.canvas.width;
            if (nextLine < data.length) {
              distributeError(nextLine - 4, 3 / 16);
              distributeError(nextLine, 5 / 16);
              if (nextLine + 4 < data.length) distributeError(nextLine + 4, 1 / 16);
            }
          }
          this.ctx.putImageData(imageData, 0, 0);
        },
        findNearestColor(r, g, b) {
          if (r > 128 && g < 128 && b < 128) return [255, 0, 0];
          const luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b;
          return luminance < 85 ? [0, 0, 0] : [255, 255, 255];
        }
      };

      /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ÎùºÎ≤®(ÌååÎùºÎØ∏ÌÑ∞) Í¥ÄÎ¶¨ (ÌïÑÏöî Ïãú) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
      const LabelManager = {
        updateParameters() {
          // ÎùºÎ≤® ÏÑ†ÌÉù Ïãú ÌïÑÏöîÌïú ÎèôÏûë (Ïó¨Í∏∞ÏÑúÎäî Îã®ÏàúÌûà Ï∫îÎ≤ÑÏä§ Í∞±Ïã†)
          CanvasManager.decodeTypes();
          CanvasManager.initCanvas();
          CanvasManager.displayOverlay();
        }
      };

      /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ BLE Í¥ÄÎ¶¨ (ÌïÑÏöî Ïãú) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
      const BLEManager = {
        bleDevice: null,
        gattServer: null,
        bleService: null,
        writeChar: null,
        writeImageChar: null,
        reconnectAttempts: 0,
        imgHexData: "",
        imgHexLength: 0,
        uploadPartIndex: 0,
        reset() {
          this.gattServer = null;
          this.bleService = null;
          this.writeChar = null;
          this.writeImageChar = null;
          document.getElementById("log").innerHTML = '';
          this.imgHexData = "";
          this.imgHexLength = 0;
          this.uploadPartIndex = 0;
        },
        async sendCommand(cmd) {
          if (this.writeChar) {
            try {
              await this.writeChar.writeValue(cmd);
            } catch (e) {
              addLog("GATT operation in progress. Ïû¨ÏãúÎèÑ...");
              await new Promise(resolve => setTimeout(resolve, 500));
              await this.writeChar.writeValue(cmd);
            }
          }
        },
        async sendCommandHex(cmdHex) {
          const cmd = Utils.hexToBytes(cmdHex);
          addLog('Send CMD: ' + cmdHex);
          await this.sendCommand(cmd);
        },
        async sendImageCommand(cmd) {
          if (this.writeImageChar) {
            try {
              await this.writeImageChar.writeValue(cmd);
            } catch (e) {
              addLog("GATT operation in progress. Ïû¨ÏãúÎèÑ...");
              await new Promise(resolve => setTimeout(resolve, 500));
              await this.writeImageChar.writeValue(cmd);
            }
          }
        },
        sendImageData(imgData) {
          this.imgHexData = imgData.replace(/(?:\r\n|\r|\n|,|0x| )/g, '');
          this.imgHexLength = this.imgHexData.length;
          this.uploadPartIndex = 0;
          console.log('Sending image of size ' + this.imgHexLength / 2);
          this.sendCommandHex("01");
        },
        handleImageState(dataHex) {
          switch (dataHex.substring(0, 2)) {
            case "01":
              if (dataHex === "01f400")
                this.sendCommandHex("02" + Utils.intToHex(this.imgHexLength / 2) + "000000");
              else
                addLog("ÏÉàÎ°úÏö¥ Ïù¥ÎØ∏ÏßÄ Ï†ÑÏÜ°ÏùÑ ÏúÑÌï¥ Ïû¨Ïó∞Í≤∞ÌïòÏÑ∏Ïöî.");
              break;
            case "02":
              addLog("Ïù¥ÎØ∏ÏßÄ Ï†ÑÏÜ° Îã®Í≥Ñ 3 ÏßÑÌñâ Ï§ë");
              this.sendCommandHex("03");
              break;
            case "05":
              if (dataHex.substring(2, 4) === "08") {
                addLog("Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú ÏôÑÎ£å, Ïó∞Í≤∞ Ïû¨ÏÑ§Ï†ï Ï§ë");
                if (this.gattServer && this.gattServer.connected) {
                  if (this.bleDevice && this.bleDevice.gatt.connected)
                    this.bleDevice.gatt.disconnect();
                }
                setTimeout(() => this.reConnect(), 5000);
              } else if (dataHex.substring(2, 4) !== "00") {
                addLog("ÏóÖÎ°úÎìú Ï§ë Ïò§Î•ò Î∞úÏÉù, Ï†ÑÏÜ° Ï§ëÎã®!");
              } else {
                this.sendNextImagePart(dataHex.substring(4, 12));
              }
              break;
          }
        },
        sendNextImagePart(partAckHex) {
          if (this.imgHexData.length > 0) {
            let currentPartHex = "";
            console.log("PartACK: " + partAckHex + " PartUpload: " + Utils.intToHex(this.uploadPartIndex));
            if (partAckHex === Utils.intToHex(this.uploadPartIndex)) {
              currentPartHex = Utils.intToHex(this.uploadPartIndex) + this.imgHexData.substring(0, 480);
              this.imgHexData = this.imgHexData.substring(480);
              setBLEStatus('Current part: ' + this.uploadPartIndex);
              this.uploadPartIndex++;
            } else {
              addLog("Ïò§Î•ò Î∞úÏÉù, ÎßàÏßÄÎßâ Î∂ÄÎ∂Ñ Ïû¨Ï†ÑÏÜ°");
              currentPartHex = Utils.intToHex(this.uploadPartIndex) + this.imgHexData.substring(0, 480);
            }
            console.log('Current Part: ' + currentPartHex);
            this.sendImageCommand(Utils.hexToBytes(currentPartHex));
          } else {
            addLog("Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú ÏôÑÎ£å");
          }
        },
        disconnect() {
          this.reset();
          addLog('Ïó∞Í≤∞ Ìï¥Ï†úÎê®.');
          document.getElementById("connectButton").innerHTML = '3. Ïó∞Í≤∞';
          document.getElementById("connectButton").disabled = false;
          document.getElementById("sendImageButton").disabled = true;
        },
        handleNotification(data) {
          addLog("Received bytes: " + Utils.bytesToHex(data.buffer));
          setTimeout(() => this.handleImageState(Utils.bytesToHex(data.buffer)), 50);
        },
        initiateConnection() {
          document.getElementById("connectButton").disabled = true;
          if (this.gattServer && this.gattServer.connected) {
            if (this.bleDevice && this.bleDevice.gatt.connected) this.bleDevice.gatt.disconnect();
            document.getElementById("connectButton").disabled = false;
          } else {
            document.getElementById("connectButton").innerHTML = 'Ïó∞Í≤∞Ï§ë...';
            this.reconnectAttempts = 0;
            navigator.bluetooth.requestDevice({
              filters: [
                { manufacturerData: [{ companyIdentifier: 0x5053 }] }
              ],
              optionalServices: [0xFEF0]
            }).then(device => {
              device.addEventListener('advertisementreceived', advertiseData);
              device.addEventListener('gattserverdisconnected', () => this.disconnect());
              this.bleDevice = device;
              console.log(device);
              this.connect();
            }).catch(handleBLEError);
          }
        },
        reConnect() {
          this.reconnectAttempts = 0;
          if (this.bleDevice && this.bleDevice.gatt.connected)
            this.bleDevice.gatt.disconnect();
          this.reset();
          addLog("Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ");
          setTimeout(() => this.connect(), 300);
        },
        connect() {
          if (!this.writeChar) {
            addLog("Connecting to: " + this.bleDevice.name);
            this.bleDevice.gatt.connect().then(server => {
              console.log('> Found GATT server');
              this.gattServer = server;
              return this.gattServer.getPrimaryService(0xFEF0);
            }).then(service => {
              console.log('> Found service');
              this.bleService = service;
              return this.bleService.getCharacteristic(0xFEF2);
            }).then(characteristic => {
              addLog('> Found write characteristic for image');
              this.writeImageChar = characteristic;
              return this.bleService.getCharacteristic(0xFEF1);
            }).then(characteristic => {
              addLog('> Found write characteristic');
              document.getElementById("connectButton").innerHTML = 'Ïó∞Í≤∞ Ìï¥Ï†ú';
              document.getElementById("connectButton").disabled = false;
              document.getElementById("sendImageButton").disabled = false;
              this.writeChar = characteristic;
              return this.writeChar.startNotifications().then(() => {
                this.writeChar.addEventListener('characteristicvaluechanged', event => {
                  this.handleNotification(event.target.value);
                });
              });
            }).catch(handleBLEError);
          }
        }
      };

      /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ BLE ÏÉÅÌÉú Î∞è Î°úÍ∑∏ Ìó¨Ìçº ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
      function setBLEStatus(statusText) {
        document.getElementById("status").innerHTML = statusText;
      }
      function addLog(logText) {
        const now = new Date();
        const time = ("0" + now.getHours()).slice(-2) + ":" +
                     ("0" + now.getMinutes()).slice(-2) + ":" +
                     ("0" + now.getSeconds()).slice(-2) + " : ";
        document.getElementById("log").innerHTML += time + logText + '<br>';
        console.log(time + logText);
        while ((document.getElementById("log").innerHTML.match(/<br>/g) || []).length > 10) {
          const firstBreak = document.getElementById("log").innerHTML.indexOf("<br>");
          document.getElementById("log").innerHTML = document.getElementById("log").innerHTML.substring(firstBreak + 4);
        }
      }
      function handleBLEError(error) {
        console.error(error);
        BLEManager.disconnect();
        if (!BLEManager.bleDevice) return;
        if (BLEManager.reconnectAttempts <= 5) {
          BLEManager.reconnectAttempts++;
          BLEManager.connect();
        } else {
          addLog("Ïó∞Í≤∞ Ïû¨ÏãúÎèÑ Ïã§Ìå®. Ïó∞Í≤∞ Ï§ëÎã®.");
          BLEManager.reconnectAttempts = 0;
        }
      }
      function advertiseData(event) {
        console.log(event);
      }

      /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà Îì±Î°ù ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
      document.getElementById('themeToggle').addEventListener('click', ThemeManager.toggleTheme);
      document.getElementById('optionsSelect').addEventListener('change', () => {
        LabelManager.updateParameters();
      });
      document.getElementById('imageUpload').addEventListener('change', function() {
        const file = this.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = function(e) {
            const img = new Image();
            img.onload = function() {
              CanvasManager.drawImage(img);
            };
            img.src = e.target.result;
          };
          reader.readAsDataURL(file);
        }
      });
      // Ïä¨ÎùºÏù¥Îçî Ïù¥Îèô Ïãú Ïã§ÏãúÍ∞Ñ Í≤∞Í≥º Í∞±Ïã†
      document.getElementById('luminanceSlider').addEventListener('input', function() {
        document.getElementById('lumVal').textContent = this.value;
        CanvasManager.displayOverlay();
      });
      document.getElementById('redSlider').addEventListener('input', function() {
        document.getElementById('redVal').textContent = this.value;
        CanvasManager.displayOverlay();
      });
      document.getElementById('pixlrButton').addEventListener('click', function() {
        window.open('https://pixlr.com/kr/editor/', '_blank');
      });
      document.getElementById('connectButton').addEventListener('click', () => {
        BLEManager.initiateConnection();
      });
      document.getElementById('sendImageButton').addEventListener('click', () => {
        BLEManager.sendImageData(document.getElementById('pixelData').value);
      });
      document.getElementById('clearLogButton').addEventListener('click', function() {
        document.getElementById('log').innerHTML = '';
      });

      // ÌéòÏù¥ÏßÄ Î°úÎìú Ïãú Ï¥àÍ∏∞Ìôî
      window.onload = function() {
        CanvasManager.initCanvas();
      };
    })();
  </script>
</body>
</html>
